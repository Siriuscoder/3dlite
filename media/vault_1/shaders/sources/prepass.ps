uniform sampler2D diffuse;
uniform sampler2D normals;
uniform samplerBuffer lightSources;
uniform isamplerBuffer lightIndexes;
uniform vec3 eye;

#ifdef CALC_ILLUM
uniform sampler2D glow;
#endif

#ifdef CALC_PARALLAX
uniform sampler2D depth;
uniform float pscale;
#endif

in vec2 iuv;
in vec3 ivv;
in mat3 itbn;
in vec3 wnorm;

<<<<<<< HEAD
const vec3 ambient = vec3(0.03, 0.03, 0.03);
const float wrapAroundFactor = 0.04;
=======
const vec3 ambient = vec3(0.05, 0.05, 0.05);
const float wrapAroundFactor = 0.1;
>>>>>>> 616633622128311494559a2b5823d8821f13bfa6
#ifdef GLASS
const float specPower = 180.0;
#else
const float specPower = 40.0;
#endif

vec3 blinn_multiple(samplerBuffer source, isamplerBuffer indexes, vec3 ambient, vec3 fragPos, 
    vec3 fragNormal, vec3 eye, float specularFactor, 
    float wrapAroundFactor, float specPower, inout vec3 linearSpec);

bool vec3zero(vec3 vec)
{
    float prec = 0.000001;
    return ((1.0-step(prec, vec.x)) * (1.0-step(prec, vec.y)) * (1.0-step(prec, vec.z))) == 1.0;
}

#ifdef CALC_PARALLAX
vec2 ParallaxMapping(vec2 tc, vec3 viewDir)
{ 
    // number of depth layers
    const float numLayers = 10;
    // calculate the size of each layer
    float layerDepth = 1.0 / numLayers;
    // depth of current layer
    float currentLayerDepth = 0.0;
    // the amount to shift the texture coordinates per layer (from vector P)
    vec2 deltaTexCoords = viewDir.xy * pscale / numLayers;

    vec2 currentTexCoords = tc;
    float currentDepthMapValue = texture2D(depth, currentTexCoords).r;
  
    while(currentLayerDepth < currentDepthMapValue)
    {
        // shift texture coordinates along direction of P
        currentTexCoords -= deltaTexCoords;
        // get depthmap value at current texture coordinates
        currentDepthMapValue = texture2D(depth, currentTexCoords).r;
        // get depth of next layer
        currentLayerDepth += layerDepth;
    }
    // Parallax Occlusion Mapping
    // get texture coordinates before collision (reverse operations)
    vec2 prevTexCoords = currentTexCoords + deltaTexCoords;

    // get depth after and before collision for linear interpolation
    float afterDepth  = currentDepthMapValue - currentLayerDepth;
    float beforeDepth = texture2D(depth, prevTexCoords).r - currentLayerDepth + layerDepth;
     
    // interpolation of texture coordinates
    float weight = afterDepth / (afterDepth - beforeDepth);
    return prevTexCoords * weight + currentTexCoords * (1.0 - weight);
}
#endif

void main()
{
    vec2 tc = iuv;
#ifdef CALC_PARALLAX
    // Offset texture coordinates with Parallax Mapping
    vec3 tanViewDir = normalize(transpose(itbn) * (eye - ivv));
    tc = ParallaxMapping(iuv, tanViewDir);
#endif

    // sampling diffuse color 
    vec4 fragDiffuse = texture2D(diffuse, tc);

#ifdef CALC_ILLUM
    // sampling glow texture and check colors
    vec3 fragGlow = texture2D(glow, tc).rgb;
    if (!vec3zero(fragGlow))
    {
        gl_FragColor = vec4(fragGlow + (fragDiffuse.rgb/3), fragDiffuse.a);
        return;
    }
#endif

    // sampling normal from normal map
    vec4 nval = texture2D(normals, tc);
#ifdef GLASS
<<<<<<< HEAD
    //nval.w = 2.5;
=======
    nval.w = 2.5;
>>>>>>> 616633622128311494559a2b5823d8821f13bfa6
#endif
    // put normal in [-1,1] range in tangent space 
    // and trasform normal to world space 
    vec3 nw = normalize(itbn * normalize(2*nval.rgb-1));

    // fix bad normals
    if (vec3zero(nw))
        nw = wnorm;

    vec3 linearSpec;
    vec3 linear = blinn_multiple(lightSources, lightIndexes, ambient, ivv, nw,
<<<<<<< HEAD
        eye, nval.w * 2, wrapAroundFactor, specPower, linearSpec);
=======
        eye, nval.w, wrapAroundFactor, specPower, linearSpec);
>>>>>>> 616633622128311494559a2b5823d8821f13bfa6

#ifdef GLASS
    fragDiffuse.a = mix(fragDiffuse.a, 1.0, length(linearSpec.rgb));
#endif

    gl_FragColor = vec4(linear * fragDiffuse.rgb, fragDiffuse.a);
}