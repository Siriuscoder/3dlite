uniform sampler2D diffuse;
uniform sampler2D normals;
#ifdef CALC_ILLUM
uniform sampler2D glow;
#endif

uniform samplerBuffer lightSources;
uniform isamplerBuffer lightIndexes;
uniform vec3 eye;

in vec2 iuv;
in vec3 ivv;
in mat3 itbn;
in vec3 wnorm;

const float wrapAroundFactor = 0.1;
const vec3 ambient = vec3(0.05, 0.05, 0.05);
#ifdef GLASS
const float specPower = 180.0;
#else
const float specPower = 40.0;
#endif

bool vec3zero(vec3 vec)
{
    float prec = 0.000001;
    return ((1.0-step(prec, vec.x)) * (1.0-step(prec, vec.y)) * (1.0-step(prec, vec.z))) == 1.0;
}

vec3 blinn_multiple(samplerBuffer source, isamplerBuffer indexes, vec3 ambient, vec3 fragPos, 
    vec3 fragNormal, vec3 eye, float specularFactor, 
    float wrapAroundFactor, float specPower, inout vec3 linearSpec);

void main()
{
    vec4 fragTexture = texture2D(diffuse, iuv);
#ifdef CALC_ILLUM
    // sampling glow texture and check colors
    vec3 fragGlow = texture2D(glow, iuv).rgb;
    if (!vec3zero(fragGlow))
    {
        gl_FragColor = vec4(fragGlow, fragTexture.a);
        return;
    }
#endif

    /* sampling normal and specular factor (w)*/
    vec4 fragNormalAndSpecular = texture2D(normals, iuv);
#ifdef GLASS
    fragNormalAndSpecular.w = 2.5;
#endif

    // put normal in [-1,1] range in tangent space 
    // and trasform normal to world space 
    vec3 nw = normalize(itbn * normalize(2*fragNormalAndSpecular.xyz-1));
    // fix bad normals
    if (vec3zero(fragNormalAndSpecular.xyz))
        nw = wnorm;

    vec3 linearSpec;
    vec3 linear = blinn_multiple(lightSources, lightIndexes, ambient, ivv, nw,
        eye, fragNormalAndSpecular.w, wrapAroundFactor, specPower, linearSpec);

#ifdef GLASS
    fragTexture.a = mix(fragTexture.a, 1.0, length(linearSpec.rgb));
#endif

    gl_FragColor = vec4(linear * fragTexture.rgb, fragTexture.a);
}