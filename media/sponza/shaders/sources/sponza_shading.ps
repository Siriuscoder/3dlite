uniform sampler2D diffuse;
#ifdef NORMAL_MAP
uniform sampler2D normals;
#endif
#ifdef SPECULAR_MAP
uniform sampler2D specular;
#endif
uniform vec3 eye;
uniform sampler2D shadowmap;

in vec2 iuv;
in vec3 ivv;
in mat3 itbn;
in vec3 wnorm;
in vec4 svv;

out vec4 fragColor;

const vec3 ambient = vec3(0.33, 0.33, 0.33);
const float wrapAroundFactor = -0.04;
const float specPower = 35.0;

vec3 blinn_multiple(vec3 fragPos, vec3 fragNormal, vec3 eye, float specularFactor, 
    float wrapAroundFactor, float specPower);
vec3 blinn_single(int type, vec3 lightDir, vec3 eyeDir, vec3 diffuse, 
    vec3 specular, vec3 normal, vec3 spotDirection, vec2 spotFactor, vec3 attenuation, 
    float specularFactor, float wrapAroundFactor, float specPower);

float shadow_func()
{
    vec3 psf = svv.xyz / svv.w;
    // transform the NDC coordinates to the range [0,1]
    psf = psf * 0.5 + 0.5;
    
    float closestDepth = texture(shadowmap, psf.xy).r;
    float currentDepth = psf.z;
    
    return currentDepth < closestDepth  ? 0.8 : 0.0;
}

bool vec3zero(vec3 vec)
{
    float prec = 0.000001;
    return ((1.0-step(prec, vec.x)) * (1.0-step(prec, vec.y)) * (1.0-step(prec, vec.z))) == 1.0;
}

void main()
{
    vec2 tc = iuv;
    vec3 nw = wnorm;
    vec3 spec = vec3(0.0, 0.0, 0.0);

    // sampling diffuse color 
    vec4 fragDiffuse = texture(diffuse, tc);

#ifdef NORMAL_MAP
    // sampling normal from normal map
    vec4 nval = texture(normals, tc);
    // put normal in [-1,1] range in tangent space 
    // and trasform normal to world space 
    nw = normalize(itbn * normalize(2*nval.rgb-1));

    // fix bad normals
    if (vec3zero(nw))
        nw = wnorm;
#endif

#ifdef SPECULAR_MAP
    spec = texture(specular, tc).xyz;
#endif

    //vec3 linearSpec;
    //vec3 linear = blinn_single(2, vec3(0, 0, 0), normalize(eye - ivv), vec3(1, 1, 1), vec3(1, 1, 1), nw, vec3(1, 1, -1), vec2(0, 0), vec3(0, 0, 0), spec.x, wrapAroundFactor, specPower, linearSpec);

    vec3 linear = blinn_multiple(ivv, nw, eye, spec.x/1.7, 
        wrapAroundFactor, specPower);
        
    float shadowFactor = shadow_func();
    vec3 final = ambient + (shadowFactor * linear);
    fragColor = vec4(final * fragDiffuse.rgb, 1.0);
}